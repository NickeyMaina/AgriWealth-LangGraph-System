from typing import Any, Dict, List
from typing_extensions import TypedDict
from pydantic import BaseModel, Field

# =============================================================
# AGENT STATE MODEL (TypedDict)
# =============================================================
class AgentState(TypedDict):
    """
    Represents the state of the LangGraph workflow, passed between agents.
    """
    question: str          # The user's original question (CLI input)
    mode: str              # The selected operational mode ('1', '2', or '3')
    db_entry: str          # The question text focused on database querying (for Planner)
    sql_query: List[str]   # List of SQL queries generated by the Planner
    query_result: str      # Final human-readable response OR raw result string
    query_rows: Dict[str, Any] # Structured dictionary of SQL results {Query_1_Success: [...]}
    attempts: int          # Counter for query rewrite attempts
    relevance: str         # Initial intent/relevance check (mostly 'relevant')
    sql_error: bool        # Flag indicating if any SQL query failed execution
    animal_type: str       # Detected species (e.g., 'cow', 'goat')
    intent: str            # Detected action intent (e.g., 'query_db')

# =============================================================
# STRUCTURED OUTPUT MODELS (Pydantic)
# =============================================================
class ConvertToSQL(BaseModel):
    """Structured output for the SQL Planner agent."""
    sql_queries: List[str] = Field(
        description="A list of 1 to 5 optimized SQL SELECT queries required to answer the user's question completely."
    )

class RewrittenQuestion(BaseModel):
    """Structured output for the Query Recovery agent."""
    question: str = Field(
        description="The rephrased, clearer, and less ambiguous question for the SQL Planner."
    )
